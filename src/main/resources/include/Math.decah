// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

  //methode pour calculer x^n a ameliorer ?
  float Puiss(float x, int n) {
    if (n == 0) return 1;
    float res = 1.0f;
    int i = 0;
    while (i<n) {
      res = res*x;
      i = i+1;
    }
    return res;
  }


  float _tan(float f) {
    int k = 0; //definit le plus grand angle courant de rotation possible
    float X = 1.0f; //Abscisse du point Mj courant
    float Y = 0.0f; //Ordonnée du point Mj courant
    float epsilone = Puiss(1/2,45); //Precision voulue sur l'angle teta
    //Precision absolue voulue = 2^-45 d'après poly
    // println("sin(f) not yet implemented");


      float temp;
      //initialiser les 6 premiers teta
      float teta_0 = 0.78539816339744830962f;
      float teta_1 = 0.099668652491162027378f;
      float teta_2 = 0.0099996666866652382063f;
      float teta_3 = 0.00099999966666686666652f;
      float teta_4 = 0.000099999999666666668667f ;
      float teta_5 = 0.0000099999999996666666667f;
      float teta_6 = 0.00000099999999999966666667f;

      while ((f >= teta_0) && (f >= epsilone)) {
        f = f - teta_0;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;

      while ((f >= teta_1) && (f >= epsilone)) {
        f = f - teta_1;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_2) && (f >= epsilone)) {
        f = f - teta_2;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_3) && (f >= epsilone)) {
        f = f - teta_3;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_4) && (f >= epsilone)) {
        f = f - teta_4;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_5) && (f >= epsilone)) {
        f = f - teta_5;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_6) && (f >= epsilone)) {
        f = f - teta_6;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;

      //a partir de k=7 teta_k = 10^-k
      while (f >= epsilone) {
        while ((f >= Puiss(10, k)) && (f >= epsilone)) {
          f = f - _Puiss(10, k);
          temp = X;
          X = X - Puiss(10, k) * Y;
          Y = Y + Puiss(10, k) * temp;
      }
      k = k+1;
      }
      return Y/X;

    }

    float sin(float f) {

      return tan(f)/(Puiss(1+tan(f)*tan(f), 1/2));
        // println("sin(f) not yet implemented");
    }
    float cos(float f) {
      return 1/(Puiss(1+tan(f)*tan(f),1/2));
        // println("cos(f) not yet implemented");
    }

    //calcul pour |f| <=1
    float asin(float f) {

      //on se limite a la puissance 9 dans
      //le Developpement en serie entière de asin
      //asin = a*f^9 + b*f^7 + c*f^5 + d*f^3 + e*f

      //initialiser les coeff sous forme de float
      float a = 0.030381944f;
      float b = 0.044642857f;
      float c = 0.075000000f;
      float d = 0.166666666f;
      float e = 1.000000000f;


      //On utilise la méthode de Horner
      return ((((a*f*f+b)*f*f+c)*f*f+d)*f*f+e)*f;
        // println("asin(f) not yet implemented");
    }

    //calcul pour |f| <=1
    float atan(float f) {
      //on se limite a la puissance 9 dans
      //le Developpement en serie entière de atan
      //atan = a*f^9 + b*f^7 + c*f^5 + d*f^3 + e*f

      //initialiser les coeff sous forme de float
      float a = 0.1111111111f;
      float b = -0.142857142f;
      float c = 0.20000000f;
      float d = -0.3333333333f;
      float e = 1.00000f;

      //On utilise la méthode de Horner
      //Pareil avec asin mais just les coeff differents
      return ((((a*f*f+b)*f*f+c)*f*f+d)*f*f+e)*f;


        // println("atan(f) not yet implemented");
    }

    //calcul de la puissance 2 du float
    int _log2f (float f) {
      int i = 0;
      if (f < 0) return log2f(-f);
      else if (f <= 1){
        while (f <= 1)
         i = i-1;
         f = f*2;
        return i;
      }

      else {
        while (f >= 2) {
          f = f/2;
          i++
        }
        return i;
      }
    }

    float ulp(float f) {

      return Puiss(2, log2f(f)) * Puiss(1/2f,23);

        // println("ulp(f) not yet implemented");
    }
}
