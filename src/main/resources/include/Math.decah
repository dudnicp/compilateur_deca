// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

  //methode pour calculer x^n a ameliorer ?
  float Puiss(float x, int n) {
    if (n == 0) return 1;
    float res = 1.0f;
    int i = 0;
    while (i<n) {
      res = res*x;
      i = i+1;
    }
    return res;
  }

  //Fait le calcul que pour des angles dans [0,pi/2]
  float tan(float f) {
    int k = 0; //definit le plus grand angle courant de rotation possible
    float X = 1.0f; //Abscisse du point Mj courant
    float Y = 0.0f; //Ordonnée du point Mj courant
    float epsilone = Puiss(1/2,45); //Precision voulue sur l'angle teta
    //Precision absolue voulue = 2^-45 d'après poly
    // println("sin(f) not yet implemented");


      float temp;
      //initialiser les 6 premiers teta
      float teta_0 = 0.78539816339744830962f;
      float teta_1 = 0.099668652491162027378f;
      float teta_2 = 0.0099996666866652382063f;
      float teta_3 = 0.00099999966666686666652f;
      float teta_4 = 0.000099999999666666668667f ;
      float teta_5 = 0.0000099999999996666666667f;
      float teta_6 = 0.00000099999999999966666667f;

      while ((f >= teta_0) && (f >= epsilone)) {
        f = f - teta_0;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;

      while ((f >= teta_1) && (f >= epsilone)) {
        f = f - teta_1;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_2) && (f >= epsilone)) {
        f = f - teta_2;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_3) && (f >= epsilone)) {
        f = f - teta_3;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_4) && (f >= epsilone)) {
        f = f - teta_4;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_5) && (f >= epsilone)) {
        f = f - teta_5;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;


      while ((f >= teta_6) && (f >= epsilone)) {
        f = f - teta_6;
        temp = X;
        X = X - Puiss(10, k) * Y;
        Y = Y + Puiss(10, k) * temp;
      }
      if (f < epsilone) return (Y/X);
      k = k+1;

      //a partir de k=7 teta_k = 10^-k
      while (f >= epsilone) {
        while ((f >= Puiss(10, k)) && (f >= epsilone)) {
          f = f - Puiss(10, k);
          temp = X;
          X = X - Puiss(10, k) * Y;
          Y = Y + Puiss(10, k) * temp;
      }
      k = k+1;
      }
      return Y/X;

    }

    //CALCUL SQRT AVEC METHODE BABYLONE (7 CHIFFRES APRES LA VIRGULE)
    float SQRT(float f){
      if (f < 0)
        System.out.println("Erreur: nombre négatif ");
      float x = 0.1f;
      int i = 0;
      while (i < 100) {
        x = (0.5f)*(x + (f/x));
        i = i+1;
      }

      return x;
    }

    float sin(float f) {
      return tan(f)/SQRT(1+tan(f)*tan(f));
        // println("sin(f) not yet implemented");
    }

    float cos(float f) {
      return 1/SQRT(1+tan(f)*tan(f));
        // println("cos(f) not yet implemented");
    }

    //calcul pour |f| <=1
    float asin(float f) {

      //on se limite a la puissance 9 dans
      //le Developpement en serie entière de asin
      //asin = a*f^9 + b*f^7 + c*f^5 + d*f^3 + e*f
      if ((f < -1) || (f > 1)) {
        println("L'arcsin n'est définit que sur [-1,1]");
        return 9999999;
      }
      //initialiser les coeff sous forme de float
      float a = 0.022372159f;
      float b = 0.030381944f;
      float c = 0.044642857f;
      float d = 0.075000000f;
      float e = 0.166666666f;
      float g = 1.000000000f;

      //On utilise la méthode de Horner
      return (((((a*f*f+b)*f*f+c)*f*f+d)*f*f+e)*f*f+g)*f;
        // println("asin(f) not yet implemented");
    }

    //atan METHODE HORNER
    //calcul pour |f| <=1
    float atan(float f) {
      //on se limite a la puissance 9 dans
      //le Developpement en serie entière de atan
      //atan = a*f^9 + b*f^7 + c*f^5 + d*f^3 + e*f

      //initialiser les coeff sous forme de float
      float a = -0.09090909f;
      float b = 0.1111111111f;
      float c = -0.142857142f;
      float d = 0.20000000f;
      float e = -0.3333333333f;
      float g = 1.00000f;

      //On utilise la méthode de Horner
      //Pareil avec asin mais just les coeff differents
      return (((((a*f*f+b)*f*f+c)*f*f+d)*f*f+e)*f*f+g)*f;


        // println("atan(f) not yet implemented");
    }
 
    //Calcul valeur absolu d'un float
    float abs(float f) {
      if (f > 0) return f;
      else return (-f);
    }

    //atan METHODE DICHOTOMIQUE
    //IL FAUT QUE f(a) ET f(b) soient de signes opposés
    //VOIR COMMENT AMELIORER LA PRECISION
    //VALABLE QUE SUR 0 ET PI/2

    float atan1(float f) {
      float a = 0.0f;
      float b = 1.141592653589793f;
    //epsilone pour la precision
      float epsilone = Puiss(1/10f,7);
      float m = 0.0f;
      while ((b-a) > epsilone) {
        m = (a+b)/2;
        // System.out.println(m);
        //if (f(a)*f(m)<=0)
        if (((tan(a)-f) * (tan(m)-f)) <= 0)
         b = m;
        else a = m;
      }
      return m;
    }


    //asin METHODE DICHOTOMIQUE a partir de atan
    float asin1(float f) {
      if ((f < -1) || (f > 1)) {
        System.out.println("L'arcsin n'est définit que sur [-1,1]");
        return 9999999;
      }

      return 2*atan1(f/(1+SQRT(1-f*f)));
    }


    //calcul de la puissance 2 du float
    int log2f (float f) {
      int i = 0;
      if (f < 0) return log2f(-f);
      else if (f <= 1){
        while (f <= 1)
         i = i-1;
         f = f*2;
        return i;
      }

      else {
        while (f >= 2) {
          f = f/2;
          i++
        }
        return i;
      }
    }

    float ulp(float f) {
       if (log2f(f)<0)
        return Puiss(1/2f, -log2f(f)) * Puiss(1/2f,23);

      else
       return Puiss(2, log2f(f)) * Puiss(1/2f,23);

        // println("ulp(f) not yet implemented");
    }
}
