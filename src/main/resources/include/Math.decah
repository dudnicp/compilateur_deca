// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca
/* This file contains the best method we've found  for
   each specified function, we've used other methods but 
   they are less effective */ 

class Math {
	
	// 32 bits constants
	
	float _2pi = 6.2831855f;
	float pi = 3.1415927f;
	float pi2 = 1.5707964f;
	float pi4 = 0.7853982f;
	float zMach = 1.1920929E-7;

	/* Not asked but will be useful later */
	float _sqrt(float f) {
		if (f < 0) {
			println("illegal parameter for sqrt, parameter must be positive");
			return -1;
		} else {
			int i = 0;
			int x = 0.1f;			
			// the number of iterations must be determined
			while (i < 50) {
				x = (0.5f) * (x + (f / x));
				i = i + 1;
			}
			return x;
		}
	}
	
	/* Not asked but will be useful later */
	float _moduloF(float f, float p) {
		/* returns f mod p i.e. the only number x that is between 0 & p
		   such that f = k * p + x with k an integer */
		if (f < 0) {
			f = -f;
		}
		while(f >= p) {
			f = f - p;
		}
		return f;
	}
	
	float _sinPI4(float f) {
		// computes the sinus function between 0 & PI / 4
		return (f - f * f * f / 6 + f * f * f * f * f / 120 - f * f * f * f * f * f * f / 5040);
	}
	
	float _cosPI4(float f) {
		// computes the cosinus function between 0 & PI / 4
		return (1 - f * f / 2 + f * f * f * f / 24 - f * f * f * f * f * f / 720
				+ f * f * f * f * f * f * f * f / 40320);
	}
	
	float _sinPI2(float f) {
		// computes the sinus function between 0 & PI / 2
		if (f > pi4) {
			return _cosPI4(pi2 - f));
		} else {
			return _sinPI4(f);
		}
	}
	
	float _cosPI2(float f) {
		// computes the sinus function between 0 & PI / 2
		if (f > pi4) {
			return _sinPI4(pi2 - f);
		} else {
			return _cosPI4(f);
		}
	}
	
	float sin(float f) {
		// computes the sinus of a float
		float sign = 1f;
		if (f < 0) {
			f = -f;
			sign = -1 * sign;
		}
		// f = f % 2*pi
		f = _moduloF(f, _2pi);
		
		// now f is < 2*pi
		if (f > pi) {
			f -= pi;
			sign = -1 * sign;
		}
		
		// now f is < pi
		if (f > pi2) {
			return sign * _cosPI2(f - pi2);
		}
		return sign * _sinPI2(f);		
	}
	
	float cos(float f) {
		/* computes the cosinus of a float using
		      the formula cos(x) = sin(x + pi/2) */
		return sin(f + pi2);
	}
	
	float atan(float f) {
		/* computes the atan function using the newton method, in a nutshell, 
		   the sequence u(n+1) = u(n) + cos²(u(n))(x - tan(u(n))) --> arctan(x) */
		float outp = 0f;
		float cosValue, sinValue;
		if (f < 0) {
			return -atan(-f);
		} else if (f > 1) {
			// arctan(f) + arctan(1/f) = sign(f) * pi / 2
			// here sign(f) > 0 since f > 0
			
			return pi2 - atan(1 / f);
		} else {
			// it is probably possible use a smaller integer instead of 10
			for (int i = 0; i < 10; i++) {
				sinValue = sin(outp);
				cosValue = cos(outp);
				outp = outp + cosValue * (cosValue * f - sinValue);
			}
			return outp;
		}
	}
	
	float asin(float f) {
		/* computes the asin using the formula
		   asin(f) = atan(f / sqrt(1 - f²))    */
		if (f < -1 || f > 1) {
			println("illegal parameter : asin can only becomputed for numbers within (-1, 1)");
		} else if (f == -1) {
			return -pi2;
		} else if (f == 1) {
			return pi2;
		} else {
			return atan(f / _sqrt(1 - f * f));
		}
	}
	
	float ulp(float f) {
		/* computes the ulp of a float */
		float tmp = 1f;
		
		if (f < 0) {
			return ulp(-f);
		} else if (1f < f && f < 2f) {
			return zMach * tmp;
		} else if (f < 1f) {
			while (f < 1f) {
				f = f * 2;
				tmp = tmp / 2;
			}
		} else {
			while (f > 2f) {
				f = f / 2;
				tmp = tmp * 2;
			}
		}
		return tmp * zMach;
	}
}

